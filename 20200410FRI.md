:v:
---
# 

---
# 리스트의 내포 표현식
- 리스트가 벡터 연산이 안되는 점을 비교적 간단한 문법으로 가능하게 함
- 리스트 내부에 반복문/조건문의 축약형 형태 전달 가능

## 문법
```python
[ 리턴값 for i in 대상 ] # 반복만 가능
[ 리턴값 for i in 대상 if 조건] # else 생략 가능
[ 참리턴값 if 조건 else 거짓리턴값 for i in 대상 ] # else 선언
```
## <mark>예제1)</mark> 10% 인상 출력
### 1) for문
```python
L1 = [1,2,3,4,5]
L2 = []
for i in L1 :
    L2.append(i * 1.1)
L2
```

### 2) map
```python
list(map(lambda x : x*1.1, L1))
```

### 3) 리스트 내포 표현식
```python
[ i * 1.1 for i in L1 ]
```

## <mark>예제2)</mark> 3보다 작은 것 출력

### 1) for문
```python
L1 = [1,2,3,4,5]
L2 = []
for i in L1 :
    if i < 3 :
        L2.append(i)
L2
```

### 2) map
```python
f1 = lambda x : x if x <3 else None
list(map(f1,L1))
```

### 3) 리스트 내포 표현식
```python

[i for i in L1 if i < 3 ]
[i for i in L1 if i < 3 else i * 2] # 불가능
```

## <mark>예제3)</mark> 3보다 작으면 'a', 크거나 같으면 'b' 리턴

```python
L1 = [1,2,3,4,5]
['a' for i in L1 if i < 3 else 'b'] # 불가능
['a' if i < 3 else 'b' for i in L1] # 가능
```

# deep copy
- deep copy는 많은 메모리 공간을 빼앗길 수가 있어서 피하는 것이 메모리관리 측면에서 좋다.
```python
L1 = [1,2,3]
L2=L1

L2[0]=10
L2
L1
# 서로 메모리를 공유한다.
# 복사를 할때마다 새로운 공간을 할당해주면 메모리가 금방 동나기때문에 메모리 절약을 위한 셋팅이다.
L3=L1[:] # 분리 복사

id(L1) # 2189261335752
id(L2) # 2189261335752
id(L3) # 11189312773192
# id 주소가 다르다.
```
---
:fire:
---